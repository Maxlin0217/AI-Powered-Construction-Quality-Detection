<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YOLOv11 æ··å‡åœŸèˆ‡æŠ¹ç°ç¼ºé™·æª¢æ¸¬</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Arial, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .header {
            background: linear-gradient(135deg, #0f4c75, #3282b8);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }
        
        .card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 20px;
        }
        
        .btn {
            background: linear-gradient(135deg, #3282b8, #0f4c75);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            width: 100%;
            transition: transform 0.2s;
        }
        
        .btn:hover { transform: translateY(-2px); }
        .btn:disabled {
            background: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .btn-upload {
            background: linear-gradient(135deg, #f39c12, #e67e22);
        }
        
        .btn-detect {
            background: linear-gradient(135deg, #8e44ad, #9b59b6);
            margin-top: 15px;
        }
        
        .error {
            background: rgba(231, 76, 60, 0.2);
            border: 2px solid #e74c3c;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .success {
            background: rgba(46, 204, 113, 0.2);
            border: 2px solid #2ecc71;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        img, canvas {
            width: 100%;
            border-radius: 10px;
            margin-bottom: 15px;
        }
        
        .result-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid #3498db;
        }
        
        .defect-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .defect-name {
            font-size: 20px;
            font-weight: bold;
            color: #3498db;
        }
        
        .badge {
            background: #3282b8;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 14px;
        }
        
        .defect-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            line-height: 1.8;
        }
        
        .defect-section {
            margin-top: 12px;
        }
        
        .defect-section-title {
            color: #f39c12;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .defect-location {
            color: #bdc3c7;
            font-size: 14px;
            margin-top: 8px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .step-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #3282b8;
        }
        
        .info {
            background: rgba(52, 152, 219, 0.2);
            border: 1px solid #3498db;
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        
        .category-item {
            background: rgba(52, 152, 219, 0.1);
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¯ YOLOv11 æ··å‡åœŸèˆ‡æŠ¹ç°ç¼ºé™·æª¢æ¸¬</h1>
            <p>AI-Powered Construction Quality Detection</p>
        </div>

        <div id="app">
            <div class="card">
                <div style="text-align: center; padding: 20px;">
                    â³ æ­£åœ¨è¼‰å…¥ ONNX Runtime...
                </div>
            </div>
        </div>
    </div>

    <script>
        // YOLO æ¨ç†é…ç½®
        let session = null;
        let currentImage = null;
        
        const INPUT_SIZE = 640;
        const CONFIDENCE_THRESHOLD = 0.25;
        const IOU_THRESHOLD = 0.45;
        
        // æ“´å±•çš„é¡åˆ¥åˆ—è¡¨ï¼ˆ11 ç¨®ç¼ºé™·ï¼‰
        const classNames = [
            'Crack', 'Efflorescence', 'Rebar', 'Rust', 'Scaling', 'Spall', 'Spallingw',
            'Hollowing', 'Bad_corner', 'Sandy_surface', 'Honeycomb'
        ];
        
        const classNamesChinese = {
            'Crack': 'è£‚ç¸«',
            'Efflorescence': 'ç™½è¯',
            'Rebar': 'é‹¼ç­‹å¤–éœ²',
            'Rust': 'é½è•',
            'Scaling': 'å‰è½',
            'Spall': 'å‰é›¢',
            'Spallingw': 'å‰é›¢Wå‹',
            'Hollowing': 'ç©ºé¼“',
            'Bad_corner': 'é™°é™½è§’ä¸é †ç›´',
            'Sandy_surface': 'è¡¨é¢ç²—ç³™/èµ·ç ‚',
            'Honeycomb': 'èœ‚çª©'
        };
        
        // å°ˆå®¶å»ºè­°æ•¸æ“šåº«
        const expertAdvice = {
            'Crack': {
                description: 'è¡¨é¢ç´°å°æˆ–æ˜é¡¯çš„è£‚ç¸«ã€‚è‹¥ç‚ºæ°´æ³¥ç²‰å…‰åœ°æ¿ï¼Œè£‚ç¸«å±¬æ–¼æ­£å¸¸ç¾è±¡ï¼ˆææ–™ç‰¹æ€§ä½¿ç„¶ï¼‰',
                causes: 'ç ‚æ¼¿é…æ¯”æ°´æ³¥éå¤šã€æŠ¹ç°å¤ªåšæœªåˆ†å±¤ã€ç•°è³ªææ–™äº¤æ¥è™•æœªåŠ å¼·ã€é¤Šè­·æ™‚é–“ä¸è¶³ï¼ˆæ¨™æº–éœ€ 28 å¤©ï¼‰ã€æ°´æ³¥ç²‰å…‰ææ–™ç‰¹æ€§',
                solutions: [
                    'ã€é‡è¦ã€‘æ°´æ³¥ç²‰å…‰ã€Œä¿è­‰æœƒè£‚ã€æ˜¯æ­£å¸¸ç¾è±¡ï¼Œè¿½æ±‚å®Œç¾è€…è«‹é¸æ“‡å…¶ä»–å·¥æ³•',
                    'é˜²è£‚æªæ–½ï¼šæ‰“åº• 28 å¤© + ç²‰å…‰ 28 å¤©ï¼ˆå…±ç´„ 3 å€‹æœˆï¼‰æ‰èƒ½é™ä½è£‚ç¸«',
                    'ç‰†æ ¹ã€äº¤æ¥è™•åŠ è¨­ 300mm å¯¬åŠ å¼·ç¶²ï¼ˆé‹¼çµ²ç¶²æˆ–ç»çº–ç¶²ï¼‰',
                    'åš´æ ¼åŸ·è¡Œåˆ†å±¤æŠ¹ç°ï¼Œå–®å±¤åšåº¦ < 9mm',
                    'ğŸ“‹ è²¬ä»»æ­¸å±¬ï¼šç”±ã€Œæ±ºå®šä½¿ç”¨æ°´æ³¥ç²‰å…‰è€…ã€è² è²¬ï¼ˆè¨­è¨ˆå¸«/å±‹ä¸»ï¼‰',
                    'âš–ï¸ è‹¥åˆç´„æœªè¨»æ˜ã€Œä¿è­‰ä¸è£‚ã€ï¼Œè£‚ç¸«ä¸æ§‹æˆç‘•ç–µ'
                ]
            },
            'Hollowing': {
                description: 'ç‰†é¢å±€éƒ¨é¼“èµ·ã€é¾œè£‚ï¼Œåš´é‡æ™‚å‡ºç¾å¡Šç‹€è„«è½',
                causes: 'åŸºå±¤æ¸…ç†ä¸æ·¨ï¼ˆæµ®ç°ã€æ²¹æ±¡ï¼‰ã€æœªæå‰æ¾†æ°´æ¿•æ½¤ã€ç”©æ¼¿å¼·åº¦ä¸è¶³',
                solutions: [
                    'æ•²é™¤ç©ºé¼“å€åŸŸï¼Œå¾¹åº•æ¸…ç†åŸºå±¤',
                    'åˆ·ä¸€é“å«å»ºç¯‰è† çš„ç´ æ°´æ³¥æ¼¿',
                    'é‡æ–°åˆ†å±¤æŠ¹ç°ä¸¦å£“å¯¦'
                ]
            },
            'Bad_corner': {
                description: 'ç‰†è§’é‚Šç·šä¸ç›´ã€æ­ªæ–œï¼Œç”¨æ–¹å°ºæª¢æŸ¥ä¸æ–¹æ­£',
                causes: 'æœªåšç°é¤…ã€æ²–ç­‹æ‰¾è¦çŸ©ã€æœªä½¿ç”¨å°ˆç”¨é™°é™½è§’æŠ¹å­ã€æœªæ›ç·šå®šä½',
                solutions: [
                    'æŠ¹ç°å‰å¿…é ˆå½ˆåå­—ç·šã€åšç°é¤…',
                    'ä½¿ç”¨é•·é å°ºèˆ‡å°ˆç”¨æŠ¹å­ä¸Šä¸‹æŠ½å¹³',
                    'åš´é‡è®Šå½¢éœ€é‡æ–°æ–½ä½œ'
                ]
            },
            'Sandy_surface': {
                description: 'ç‰†é¢è‰²æ¾¤ä¸å‡ã€æ¥æ§æ˜é¡¯ï¼Œè¡¨é¢é¬†æ•£æ˜“æ‰ç ‚ã€‚ã€æ³¨æ„ã€‘è¡¨é¢æœ‰å­”æ´ä¹Ÿæ˜¯æ°´æ³¥ç²‰å…‰çš„æ­£å¸¸ç¾è±¡',
                causes: 'é¤Šè­·ä¸è¶³å¤±æ°´éå¿«ã€ä½¿ç”¨éæ™‚ç°ï¼ˆè¶…é 3 å°æ™‚çš„ç ‚æ¼¿ï¼‰ã€å£“å…‰æ™‚é–“ä¸ç•¶ã€æ”ªæ‹Œéç¨‹ç©ºæ°£é€²å…¥ï¼ˆæ°£å­”ç„¡æ³•å®Œå…¨é¿å…ï¼‰',
                solutions: [
                    'æŠ¹ç°å¾Œ 12 å°æ™‚å…§é–‹å§‹å™´æ°´é¤Šè­·ï¼ŒæŒçºŒ 7 å¤©',
                    'åš´ç¦ä½¿ç”¨è¶…é 3 å°æ™‚çš„ã€Œéæ™‚ç°ã€',
                    'åš´é‡å€åŸŸéœ€éŸé™¤é‡åš',
                    'âš ï¸ æ°£å­”å±¬æ­£å¸¸ç¯„åœï¼šæ‰€æœ‰éœ€æ”ªæ‹Œçš„å»ºæéƒ½æœƒæœ‰æ°£å­”',
                    'ğŸ’¡ å®Œå…¨ç„¡å­”æ´éœ€ç”¨æ©Ÿå™¨å£“ï¼ˆä½†ä¸€èˆ¬å¸«å‚…éƒ½ä¸åšï¼‰'
                ]
            },
            'Efflorescence': {
                description: 'ç‰†é¢å‡ºç¾ç™½è‰²çµæ™¶ç‰©ï¼ˆé¹½æç¾è±¡ï¼‰',
                causes: 'æ°´æ³¥æˆ–ç ‚ä¸­å«å¯æº¶æ€§é¹½é¡ã€é¤Šè­·æœŸéåº¦æ½®æ¿•',
                solutions: [
                    'ç”¨ç¨€é¹½é…¸æ¸…æ´—ä¸¦å……åˆ†æ²–æ°´',
                    'é‡åšæ™‚é¸ç”¨ä½é¹¼æ°´æ³¥',
                    'åŠ å¼·é˜²æ°´æªæ–½'
                ]
            },
            'Rebar': {
                description: 'é‹¼ç­‹å¤–éœ²ï¼Œä¿è­·å±¤ä¸è¶³',
                causes: 'ä¿è­·å±¤åšåº¦ä¸è¶³ã€æ··å‡åœŸå‰è½',
                solutions: [
                    'æ¸…ç†é½è•ï¼Œå¡—åˆ·é˜²é½åŠ‘',
                    'ä½¿ç”¨é«˜å¼·åº¦ä¿®è£œç ‚æ¼¿ä¿®å¾©',
                    'åš´é‡æ™‚éœ€çµæ§‹è£œå¼·'
                ]
            },
            'Rust': {
                description: 'é‹¼ç­‹é½è•ï¼Œè¡¨é¢å‡ºç¾é½æ–‘',
                causes: 'ä¿è­·å±¤ç ´æã€é•·æœŸæ½®æ¿•ç’°å¢ƒ',
                solutions: [
                    'æ¸…é™¤é½è•è‡³é‡‘å±¬å…‰æ¾¤',
                    'å¡—åˆ·é˜²é½åº•æ¼†',
                    'ä¿®å¾©ä¿è­·å±¤ä¸¦é˜²æ°´'
                ]
            },
            'Scaling': {
                description: 'è¡¨é¢å±¤ç‹€å‰è½',
                causes: 'åŸºå±¤è™•ç†ä¸ç•¶ã€ææ–™é…æ¯”å•é¡Œ',
                solutions: [
                    'æ¸…é™¤å‰è½éƒ¨ä½',
                    'é‡æ–°æ–½ä½œä¸¦åŠ å¼·é¤Šè­·',
                    'æª¢æŸ¥ææ–™å“è³ª'
                ]
            },
            'Spall': {
                description: 'æ··å‡åœŸå¡Šç‹€å‰é›¢',
                causes: 'å‡èæå®³ã€é‹¼ç­‹é½è„¹ã€è¡æ“Šæå‚·',
                solutions: [
                    'è©•ä¼°çµæ§‹å®‰å…¨',
                    'ä½¿ç”¨èšåˆç‰©ç ‚æ¼¿ä¿®è£œ',
                    'å¿…è¦æ™‚é€²è¡Œçµæ§‹è£œå¼·'
                ]
            },
            'Spallingw': {
                description: 'Wå‹å‰é›¢ç ´æ',
                causes: 'æ‡‰åŠ›é›†ä¸­ã€ææ–™åŠ£åŒ–',
                solutions: [
                    'å°ˆæ¥­çµæ§‹è©•ä¼°',
                    'æŒ‰è¦ç¯„é€²è¡Œä¿®å¾©',
                    'ç›£æ¸¬å¾ŒçºŒç™¼å±•'
                ]
            },
            'Honeycomb': {
                description: 'è¡¨é¢å‘ˆç¾èœ‚çª©ç‹€å­”æ´',
                causes: 'æŒ¯æ—ä¸å¯¦ã€æ¼æŒ¯ã€é…æ¯”ä¸ç•¶',
                solutions: [
                    'è©•ä¼°æ·±åº¦å’Œç¯„åœ',
                    'ä½¿ç”¨é«˜æµå‹•æ€§ä¿®è£œæ–™å¡«å……',
                    'åš´é‡æ™‚éœ€é‘¿é™¤é‡åš'
                ]
            }
        };
        
        // è¼‰å…¥ ONNX Runtime
        function tryLoadORT() {
            const localScript = document.createElement('script');
            localScript.src = './ort.min.js';
            localScript.onload = function() {
                console.log('âœ… æœ¬åœ°è¼‰å…¥ ONNX Runtime');
                checkORT();
            };
            localScript.onerror = function() {
                console.log('æœ¬åœ°æª”æ¡ˆä¸å­˜åœ¨ï¼Œå˜—è©¦ CDN...');
                tryLoadFromCDN();
            };
            document.head.appendChild(localScript);
        }
        
        function tryLoadFromCDN() {
            const script = document.createElement('script');
            script.src = 'https://unpkg.com/onnxruntime-web@1.19.2/dist/ort.min.js';
            script.onload = function() {
                console.log('âœ… CDN è¼‰å…¥ ONNX Runtime');
                checkORT();
            };
            script.onerror = function() {
                console.error('âŒ CDN è¼‰å…¥å¤±æ•—');
                showOfflineInstructions();
            };
            document.head.appendChild(script);
        }
        
        function checkORT() {
            if (typeof ort !== 'undefined') {
                console.log('âœ… ONNX Runtime æº–å‚™å°±ç·’');
                showModelUpload();
            } else {
                setTimeout(checkORT, 100);
            }
        }
        
        function showOfflineInstructions() {
            document.getElementById('app').innerHTML = `
                <div class="error">
                    âŒ ç„¡æ³•è¼‰å…¥ ONNX Runtime<br>
                    <small>è«‹ç¢ºä¿æ‰€æœ‰æª”æ¡ˆåœ¨åŒä¸€è³‡æ–™å¤¾</small>
                </div>
                <div class="card">
                    <button class="btn" onclick="location.reload()">ğŸ”„ é‡æ–°è¼‰å…¥</button>
                </div>
            `;
        }
        
        function showModelUpload() {
            const app = document.getElementById('app');
            app.innerHTML = `
                <div class="success">âœ… ONNX Runtime å·²å°±ç·’</div>
                <div class="card">
                    <div class="step-title">âš¡ æ­¥é©Ÿ 1ï¼šè¼‰å…¥ YOLOv11 æ¨¡å‹</div>
                    <button class="btn btn-upload" onclick="selectModel()">ğŸ“¤ é¸æ“‡æ¨¡å‹æª”æ¡ˆ (.onnx)</button>
                    <input type="file" id="modelInput" accept=".onnx" onchange="loadModel(this)">
                    <div class="info">
                        <strong>ğŸ“‹ æ”¯æ´æª¢æ¸¬ (11 ç¨®ç¼ºé™·)ï¼š</strong>
                        <div class="category-grid">
                            <div class="category-item">ğŸ”´ è£‚ç¸« (Crack)</div>
                            <div class="category-item">âšª ç™½è¯ (Efflorescence)</div>
                            <div class="category-item">ğŸ”§ é‹¼ç­‹å¤–éœ² (Rebar)</div>
                            <div class="category-item">ğŸŸ  é½è• (Rust)</div>
                            <div class="category-item">ğŸŸ¡ å‰è½ (Scaling)</div>
                            <div class="category-item">ğŸŸ¢ å‰é›¢ (Spall)</div>
                            <div class="category-item">ğŸ”µ å‰é›¢Wå‹ (Spallingw)</div>
                            <div class="category-item">ğŸŸ£ ç©ºé¼“ (Hollowing)</div>
                            <div class="category-item">ğŸŸ¤ é™°é™½è§’ä¸é †ç›´ (Bad_corner)</div>
                            <div class="category-item">âš« è¡¨é¢ç²—ç³™ (Sandy_surface)</div>
                            <div class="category-item">ğŸ”¶ èœ‚çª© (Honeycomb)</div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        function selectModel() {
            document.getElementById('modelInput').click();
        }
        
        async function loadModel(input) {
            const file = input.files[0];
            if (!file) return;
            
            const app = document.getElementById('app');
            app.innerHTML = '<div class="card"><div style="text-align: center; padding: 20px;">â³ è¼‰å…¥æ¨¡å‹ä¸­...</div></div>';
            
            try {
                const arrayBuffer = await file.arrayBuffer();
                session = await ort.InferenceSession.create(arrayBuffer);
                
                console.log('âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸ');
                
                app.innerHTML = `
                    <div class="success">âœ… YOLOv11 æ¨¡å‹å·²è¼‰å…¥</div>
                    <div class="card">
                        <div class="step-title">ğŸ“¸ æ­¥é©Ÿ 2ï¼šä¸Šå‚³æ–½å·¥ç…§ç‰‡</div>
                        <button class="btn btn-upload" onclick="selectImage()">ğŸ“· é¸æ“‡ç…§ç‰‡</button>
                        <input type="file" id="imageInput" accept="image/*" onchange="loadImage(this)">
                        <div class="info">
                            ğŸ’¡ å¯æª¢æ¸¬æ··å‡åœŸèˆ‡æŠ¹ç°æ–½å·¥çš„å„é¡ç¼ºé™·ï¼Œä¸¦æä¾›å°ˆæ¥­ä¿®å¾©å»ºè­°
                        </div>
                    </div>
                `;
            } catch (err) {
                console.error('æ¨¡å‹è¼‰å…¥éŒ¯èª¤:', err);
                app.innerHTML = `
                    <div class="error">âŒ æ¨¡å‹è¼‰å…¥å¤±æ•—ï¼š${err.message}</div>
                    <div class="card">
                        <button class="btn" onclick="showModelUpload()">ğŸ”„ é‡è©¦</button>
                    </div>
                `;
            }
        }
        
        function selectImage() {
            document.getElementById('imageInput').click();
        }
        
        function loadImage(input) {
            const file = input.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                currentImage = e.target.result;
                showImagePreview();
            };
            reader.readAsDataURL(file);
        }
        
        function showImagePreview() {
            const app = document.getElementById('app');
            app.innerHTML = `
                <div class="success">âœ… æº–å‚™å°±ç·’</div>
                <div class="card">
                    <img src="${currentImage}">
                    <button class="btn btn-detect" onclick="runDetection()">ğŸ¯ é–‹å§‹ YOLO æ¨ç†</button>
                    <button class="btn" onclick="resetAndSelectNewImage()" style="margin-top: 10px; background: #555;">ğŸ“· é‡é¸ç…§ç‰‡</button>
                </div>
            `;
        }
        
        function resetAndSelectNewImage() {
            currentImage = null;
            const app = document.getElementById('app');
            app.innerHTML = `
                <div class="success">âœ… YOLOv11 æ¨¡å‹å·²è¼‰å…¥</div>
                <div class="card">
                    <div class="step-title">ğŸ“¸ æ­¥é©Ÿ 2ï¼šä¸Šå‚³æ–½å·¥ç…§ç‰‡</div>
                    <button class="btn btn-upload" onclick="selectImage()">ğŸ“· é¸æ“‡ç…§ç‰‡</button>
                    <input type="file" id="imageInput" accept="image/*" onchange="loadImage(this)">
                </div>
            `;
        }
        
        async function runDetection() {
            const btn = event.target;
            btn.disabled = true;
            btn.textContent = 'â³ YOLO æ¨ç†ä¸­...';
            
            try {
                const img = new Image();
                img.src = currentImage;
                await new Promise(resolve => img.onload = resolve);
                
                console.log('ğŸ“¸ åœ–ç‰‡å°ºå¯¸:', img.width, 'x', img.height);
                
                const input = await preprocessImage(img);
                const feeds = {};
                feeds[session.inputNames[0]] = input;
                
                console.log('ğŸš€ é–‹å§‹æ¨ç†...');
                const results = await session.run(feeds);
                console.log('âœ… æ¨ç†å®Œæˆ');
                
                const detections = postprocess(results[session.outputNames[0]], img.width, img.height);
                console.log('ğŸ¯ æª¢æ¸¬åˆ°', detections.length, 'å€‹ç¼ºé™·');
                
                showResults(img, detections);
            } catch (err) {
                console.error('æ¨ç†éŒ¯èª¤:', err);
                document.getElementById('app').innerHTML = `
                    <div class="error">âŒ æ¨ç†å¤±æ•—ï¼š${err.message}</div>
                    <div class="card">
                        <button class="btn" onclick="showImagePreview()">ğŸ”„ é‡è©¦</button>
                    </div>
                `;
            }
        }
        
        async function preprocessImage(img) {
            const canvas = document.createElement('canvas');
            canvas.width = INPUT_SIZE;
            canvas.height = INPUT_SIZE;
            const ctx = canvas.getContext('2d');
            
            const scale = Math.min(INPUT_SIZE / img.width, INPUT_SIZE / img.height);
            const scaledWidth = img.width * scale;
            const scaledHeight = img.height * scale;
            const x = (INPUT_SIZE - scaledWidth) / 2;
            const y = (INPUT_SIZE - scaledHeight) / 2;
            
            ctx.fillStyle = '#114';
            ctx.fillRect(0, 0, INPUT_SIZE, INPUT_SIZE);
            ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
            
            const imageData = ctx.getImageData(0, 0, INPUT_SIZE, INPUT_SIZE);
            const pixels = imageData.data;
            
            const red = [], green = [], blue = [];
            for (let i = 0; i < pixels.length; i += 4) {
                red.push(pixels[i] / 255);
                green.push(pixels[i + 1] / 255);
                blue.push(pixels[i + 2] / 255);
            }
            
            const input = Float32Array.from([...red, ...green, ...blue]);
            return new ort.Tensor('float32', input, [1, 3, INPUT_SIZE, INPUT_SIZE]);
        }
        
        function postprocess(output, imgWidth, imgHeight) {
            const data = output.data;
            const dims = output.dims;
            
            const numClasses = classNames.length;
            const numBoxes = dims[2] || dims[1];
            
            const boxes = [];
            const scale = Math.min(INPUT_SIZE / imgWidth, INPUT_SIZE / imgHeight);
            
            for (let i = 0; i < numBoxes; i++) {
                let maxScore = 0;
                let maxClass = 0;
                
                for (let c = 0; c < numClasses; c++) {
                    const score = data[i + (4 + c) * numBoxes];
                    if (score > maxScore) {
                        maxScore = score;
                        maxClass = c;
                    }
                }
                
                if (maxScore < CONFIDENCE_THRESHOLD) continue;
                
                const x = data[i];
                const y = data[i + numBoxes];
                const w = data[i + 2 * numBoxes];
                const h = data[i + 3 * numBoxes];
                
                const x1 = ((x - w / 2) - (INPUT_SIZE - imgWidth * scale) / 2) / scale;
                const y1 = ((y - h / 2) - (INPUT_SIZE - imgHeight * scale) / 2) / scale;
                const x2 = ((x + w / 2) - (INPUT_SIZE - imgWidth * scale) / 2) / scale;
                const y2 = ((y + h / 2) - (INPUT_SIZE - imgHeight * scale) / 2) / scale;
                
                boxes.push({
                    x1, y1, x2, y2,
                    score: maxScore,
                    class: maxClass,
                    className: classNames[maxClass],
                    chineseName: classNamesChinese[classNames[maxClass]]
                });
            }
            
            return nms(boxes, IOU_THRESHOLD);
        }
        
        function nms(boxes, iouThreshold) {
            boxes.sort((a, b) => b.score - a.score);
            
            const keep = [];
            while (boxes.length > 0) {
                keep.push(boxes[0]);
                boxes = boxes.slice(1).filter(box => {
                    const iou = calculateIOU(keep[keep.length - 1], box);
                    return iou < iouThreshold;
                });
            }
            
            return keep;
        }
        
        function calculateIOU(box1, box2) {
            const x1 = Math.max(box1.x1, box2.x1);
            const y1 = Math.max(box1.y1, box2.y1);
            const x2 = Math.min(box1.x2, box2.x2);
            const y2 = Math.min(box1.y2, box2.y2);
            
            const intersection = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);
            const area1 = (box1.x2 - box1.x1) * (box1.y2 - box1.y1);
            const area2 = (box2.x2 - box2.x1) * (box2.y2 - box2.y1);
            const union = area1 + area2 - intersection;
            
            return intersection / union;
        }
        
        function showResults(img, detections) {
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            
            ctx.drawImage(img, 0, 0);
            
            const colors = ['#e74c3c', '#3498db', '#f39c12', '#2ecc71', '#9b59b6', '#1abc9c', '#e67e22', '#95a5a6', '#34495e', '#16a085', '#d35400'];
            
            detections.forEach((det) => {
                const color = colors[det.class % colors.length];
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 4;
                ctx.strokeRect(det.x1, det.y1, det.x2 - det.x1, det.y2 - det.y1);
                
                ctx.fillStyle = color;
                const label = `${det.chineseName} ${(det.score * 100).toFixed(1)}%`;
                ctx.font = 'bold 20px Arial';
                const textWidth = ctx.measureText(label).width;
                ctx.fillRect(det.x1, det.y1 - 35, textWidth + 20, 35);
                
                ctx.fillStyle = 'white';
                ctx.fillText(label, det.x1 + 10, det.y1 - 10);
            });
            
            const resultHTML = detections.map(det => {
                const advice = expertAdvice[det.className] || {
                    description: 'ç¼ºé™·æè¿°æš«ç„¡',
                    causes: 'åŸå› åˆ†æä¸­',
                    solutions: ['è«‹è«®è©¢å°ˆæ¥­äººå“¡']
                };
                
                return `
                    <div class="result-item">
                        <div class="defect-header">
                            <div class="defect-name">${det.chineseName}</div>
                            <span class="badge">ä¿¡å¿ƒåº¦: ${(det.score * 100).toFixed(1)}%</span>
                        </div>
                        
                        <div class="defect-location">
                            ğŸ“ ä½ç½®: (${Math.round(det.x1)}, ${Math.round(det.y1)}) â†’ (${Math.round(det.x2)}, ${Math.round(det.y2)})
                        </div>
                        
                        <div class="defect-info">
                            <div class="defect-section">
                                <div class="defect-section-title">ğŸ” ç¼ºé™·æè¿°ï¼š</div>
                                ${advice.description}
                            </div>
                            
                            <div class="defect-section">
                                <div class="defect-section-title">âš ï¸ å¯èƒ½åŸå› ï¼š</div>
                                ${advice.causes}
                            </div>
                            
                            <div class="defect-section">
                                <div class="defect-section-title">âœ… ä¿®å¾©å»ºè­°ï¼š</div>
                                ${advice.solutions.map((s, i) => `${i + 1}. ${s}`).join('<br>')}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            const app = document.getElementById('app');
            app.innerHTML = `
                <div class="success">
                    âœ… YOLO æ¨ç†å®Œæˆï¼æª¢æ¸¬åˆ° ${detections.length} å€‹ç¼ºé™·
                </div>
                <div class="card">
                    <canvas id="resultCanvas" width="${canvas.width}" height="${canvas.height}"></canvas>
                    ${detections.length > 0 ? `
                        <div style="margin-top: 20px;">
                            <h3 style="margin-bottom: 15px;">ğŸ“Š æª¢æ¸¬çµæœèˆ‡å°ˆå®¶å»ºè­°ï¼š</h3>
                            ${resultHTML}
                        </div>
                    ` : '<p style="text-align: center; padding: 20px;">âœ… æœªæª¢æ¸¬åˆ°ç¼ºé™·</p>'}
                    <button class="btn" onclick="resetAndSelectNewImage()" style="margin-top: 20px;">ğŸ“· æª¢æ¸¬æ–°ç…§ç‰‡</button>
                </div>
            `;
            
            const displayCanvas = document.getElementById('resultCanvas');
            displayCanvas.getContext('2d').drawImage(canvas, 0, 0);
        }
        
        window.addEventListener('load', function() {
            console.log('é–‹å§‹è¼‰å…¥ ONNX Runtime...');
            tryLoadORT();
        });
    </script>
</body>
</html>
